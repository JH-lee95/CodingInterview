문제 설명
배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,

arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.
배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.


코드컨셉:
1. 빈리스트를 만들고, 주어진 리스트의 첫번째 원소만 추가한다. 
2. 주어진 리스트를 2번째 부터 참조하는 for 구문을 만든다. (i와 i+1 의 비교를 위해)
3. 리스트의 i번째와 i+1째를 비교한다.
4. 숫자가 다를 때만 처음에 만든 빈리스트에 추가한다.


ver1.
## 코드 시작 ##
def solution(arr):
    
    i=0
    temp=[]
    temp.append(arr[0])
    for num in arr[1:]:
        if arr[i]!=num:
            temp.append(num)
        i+=1
    
    return temp
## 코드 종료 ##

ver2.
코드컨셉:
1.다른 사람의 풀이이다.
2.a라는 빈리스트를 만들고 a의 맨끝 요소와 주어진 리스트의 원소를 하나씩 비교하는 것이 컨셉이다.
3.이 때 빈리스트 a에 a[-1]을 통하여 원소를 참조 하려고 하면 에러가 발생한다. (참조할 원소가 없기 때문에)
4.이를 방지하기 위해 a[-1:] 을 활용하여 원소를 참조하는 것이 아닌 a의 끝자리만 포함하는 리스트를 다시 만드는 것이다.
5.마찬가지로 비교 대상도 원소인 i가 아닌 i라는 원소를 가진 리스트 [i]가 된다.
6.슬라이싱을 적극 활용한 멋있는 방법이다!! 더 공부해야겠다.

## 코드 시작 ##
def no_continuous(s):
    a = []
    for i in s:
        if a[-1:] == [i]: continue
        a.append(i)
    return a
## 코드 종료 ##
